"""Generate markdown reports from Bedrock analysis results."""

import logging
from datetime import datetime
from typing import Any, Dict

logger = logging.getLogger(__name__)


class ReportGenerator:
    """Generate markdown reports from gap analysis results."""

    @staticmethod
    def generate_report(
        bedrock_response: str,
        module_name: str,
        api_name: str = "Bank API",
        include_metadata: bool = True,
    ) -> str:
        """Generate a markdown report from Bedrock analysis.

        Args:
            bedrock_response: Raw response text from Bedrock
            module_name: Name of the Woob module analyzed
            api_name: Name of the API being analyzed
            include_metadata: Whether to include metadata header

        Returns:
            Formatted markdown report
        """
        report = ""

        # Add metadata header
        if include_metadata:
            report += ReportGenerator._generate_header(module_name, api_name)

        # Add the analysis content
        report += bedrock_response

        # Add footer
        report += ReportGenerator._generate_footer()

        return report

    @staticmethod
    def _generate_header(module_name: str, api_name: str) -> str:
        """Generate report header with metadata.

        Args:
            module_name: Woob module name
            api_name: API name

        Returns:
            Markdown header
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        header = f"""# Gap Analysis Report

## Analysis Details

- **Module**: `{module_name}`
- **API**: {api_name}
- **Generated**: {timestamp}
- **Tool**: Woob API Gap Analyzer

---

"""
        return header

    @staticmethod
    def _generate_footer() -> str:
        """Generate report footer.

        Returns:
            Markdown footer
        """
        footer = """

---

## Report Information

This report was generated by the Woob API Gap Analyzer, which compares:
1. **API Specification**: What the Bank API theoretically provides (Swagger/OpenAPI)
2. **Woob Implementation**: What the Woob module actually extracts

The analysis identifies discrepancies, missing fields, type mismatches, and other issues
that may affect data extraction accuracy and completeness.

### How to Use This Report

1. **Review Issues by Severity**: Start with High severity issues as they will cause failures
2. **Check Locations**: Each issue includes the exact file and line number in the Woob code
3. **Understand the Impact**: Read the impact section to understand consequences
4. **Apply Fixes**: Use the suggested fixes to update the Woob implementation
5. **Verify Changes**: Re-run the analysis after making changes to confirm fixes

### Next Steps

- [ ] Review all High severity issues
- [ ] Review all Medium severity issues
- [ ] Implement suggested fixes
- [ ] Re-run analysis to verify improvements
- [ ] Update documentation if needed
"""
        return footer

    @staticmethod
    def save_report(report: str, output_path: str) -> None:
        """Save report to file.

        Args:
            report: Markdown report content
            output_path: Path to save report to

        Raises:
            IOError: If file cannot be written
        """
        try:
            with open(output_path, "w", encoding="utf-8") as f:
                f.write(report)
            logger.info(f"Report saved to: {output_path}")
        except IOError as e:
            logger.error(f"Failed to save report: {e}")
            raise

    @staticmethod
    def extract_statistics(bedrock_response: str) -> Dict[str, Any]:
        """Extract statistics from Bedrock response.

        Args:
            bedrock_response: Raw response text from Bedrock

        Returns:
            Dictionary with statistics
        """
        stats = {
            "total_issues": 0,
            "high_severity": 0,
            "medium_severity": 0,
            "low_severity": 0,
            "has_recommendations": False,
        }

        # Count issues by severity
        high_count = bedrock_response.count("**Severity**: High")
        medium_count = bedrock_response.count("**Severity**: Medium")
        low_count = bedrock_response.count("**Severity**: Low")

        stats["high_severity"] = high_count
        stats["medium_severity"] = medium_count
        stats["low_severity"] = low_count
        stats["total_issues"] = high_count + medium_count + low_count

        # Check for recommendations
        stats["has_recommendations"] = (
            "Recommendation" in bedrock_response or "recommendation" in bedrock_response
        )

        return stats

    @staticmethod
    def generate_summary(stats: Dict[str, Any]) -> str:
        """Generate a summary section based on statistics.

        Args:
            stats: Statistics dictionary from extract_statistics()

        Returns:
            Markdown summary section
        """
        summary = f"""## Summary

- **Total Issues Found**: {stats["total_issues"]}
  - High Severity: {stats["high_severity"]}
  - Medium Severity: {stats["medium_severity"]}
  - Low Severity: {stats["low_severity"]}
- **Recommendations Provided**: {"Yes" if stats["has_recommendations"] else "No"}

"""
        return summary

    @staticmethod
    def format_report_with_summary(
        bedrock_response: str,
        module_name: str,
        api_name: str = "Bank API",
    ) -> str:
        """Generate complete report with header, summary, and footer.

        Args:
            bedrock_response: Raw response from Bedrock
            module_name: Woob module name
            api_name: API name

        Returns:
            Complete formatted markdown report
        """
        # Extract statistics
        stats = ReportGenerator.extract_statistics(bedrock_response)

        # Build report
        report = ReportGenerator._generate_header(module_name, api_name)
        report += ReportGenerator.generate_summary(stats)
        report += "---\n\n"
        report += bedrock_response
        report += ReportGenerator._generate_footer()

        return report
